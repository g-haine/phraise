# Ce fichier contient les différentes fonctions utiles à plusieurs scripts à la fois

# Mail, Scopus key and Springer key
if [ -f .env ]; then
    source .env
else
    echo "Erreur : fichier .env introuvable !" >&2
    exit 1
fi

# Une fonction de slugify des titres
slugify () {
    echo "${1:0:240}" |
    iconv -t ascii//TRANSLIT |
    tr '[:upper:]' '[:lower:]' |
    tr -cs 'a-z0-9' '-' |
    sed -E 's/^-+|-+$//g'
}

# Une fonctione qui récupère le bibtex et le formatte
print_bib () {
    local doi=$1
    local bibfile=$2
    doiBib="$(curl -s -LH "Accept: application/x-bibtex;q=1.0" https://doi.org/$doi
)"
    bibtex="$(echo "$doiBib" \
        | sed -e 's/ @/@/g' \
        | sed -e 's/},/},\n /g' \
        | sed -e 's/, series/,\n  series/g' \
        | sed -e 's/, pages/,\n  pages/g' \
        | sed -e 's/, title/,\n  title/g' \
        | sed -e '/title/s/={/={{/g' \
        | sed -e '/title/s/},/}},/g' \
        | sed -e 's/ }/\n}/g' \
        | sed -e 's/, }/\n}/g' \
        | sed -e '/pages/s/–/--/g' \
        | sed -e '/month/d' \
        | sed -e '/url/d' \
        | tac | sed -e '2 s/,//g' | tac)"
    echo "$bibtex" > $bibfile
}

# Remplace les $ par les balises markdwon de mathjax
mathjaxify () {
    text=$(echo "$1" | sed -e 's/$$/$/g') # au cas où il y aurait des double $
    text=$(echo "$text" | sed -e 's/{{/{[[:space:]]{/g') # Pour éviter les conflits avec jekyll
    text=$(echo "$text" | sed -e 's/}}/}[[:space:]]}/g') # Pour éviter les conflits avec jekyll
    # Mathjax \( ... \) avec les escape nécessaires
    text=$(echo "$text" \
    | awk '{
        in_math = 0;
        for (i=1; i<=length($0); i++) {
            c = substr($0, i, 1);
            if (c == "$") {
                if (in_math == 0) {
                    printf "\\\\( ";
                    in_math = 1;
                } else {
                    printf " \\\\)";
                    in_math = 0;
                }
            } else {
                printf "%s", c;
            }
        }
        printf "\n";
    }')
    
    echo "$text"
}

# Appel à l'API de crossref
fetch_metadata_crossref () {
    local doi=$1
    request=$(curl -s -w "%{http_code}" "https://api.crossref.org/works/$doi?mailto=$MAIL")
    http=${request: -3}
    response=${request:: -3}
    if [[ "$http" -eq 200 ]]; then
        echo "$response"
    else
        echo '{"status":"error"}'
    fi
}

# Appel à l'API de scopus
fetch_metadata_scopus () {
    local doi=$1
    echo $(curl -s -X GET "https://api.elsevier.com/content/article/doi/$doi" -H "Accept: application/json" -H "X-ELS-APIKey: $SCOPUS_API_KEY")
}

# Abstract via scopus
abstract_from_scopus () {
    local json=$1
    if ! jq -e . >/dev/null 2>&1 <<<"$json"; then
        return 0
    fi

    local abs
    abs=$(jq -r '
        (
          .["full-text-retrieval-response"].coredata."dc:description"
          // ""
        )
        | tostring
        | gsub("<[^>]+>"; "")
        | gsub("\\s+"; " ")
        | gsub("^\\s+|\\s+$"; "")
    ' <<<"$json")

    [ -n "$abs" ] && [ "$abs" != "null" ] && echo "$abs"
}

# Keywords via scopus
keywords_from_scopus () {
    local json=$1
    if ! jq -e . >/dev/null 2>&1 <<<"$json"; then
        return 0
    fi

    local out
    out=$(jq -r '
        def norm(s):
          s | tostring
            | ascii_downcase
            | gsub("^\\s+|\\s+$"; "");

        def from_subjects:
          (
            .["full-text-retrieval-response"].coredata."dcterms:subject"
            // []
          )
          | map(.["$"] // empty)
          | map(norm(.))
          | map(select(length > 0));

        def from_authkeywords:
          (
            .["full-text-retrieval-response"].coredata.authkeywords
            // ""
          )
          | tostring
          | if . == "" or . == "null" then [] else
              ( split("[|;,]"; "x") | map(norm(.)) )
            end
          | map(select(length > 0));

        ( (from_subjects + from_authkeywords) | unique ) | join(", ")
    ' <<<"$json")

    [ -n "$out" ] && [ "$out" != "null" ] && echo "$out"
}

# event via scopus : super pour le nom de la conf IFAC
event_from_scopus () {
    local json=$1
    if echo "$json" | jq empty 2>/dev/null; then
        local scopus_nameIssue=$(echo "$json" | jq -r '.["full-text-retrieval-response"].coredata."prism:issueName" // ""')
        [ -n "$scopus_nameIssue" ] && echo "$scopus_nameIssue"
    fi
}

# Appel à l'API de Springer
fetch_metadata_springer () {
    local doi=$1
    echo $(curl -s -X GET "https://api.springernature.com/meta/v2/json?q=doi:$doi&api_key=$SPRINGER_API_KEY")
}

# Abstract via Springer
abstract_from_springer () {
    local json=$1
    if ! jq -e . >/dev/null 2>&1 <<<"$json"; then
        return 0
    fi

    local abs
    abs=$(jq -r '
        (
          .records[0].abstract
          // ""
        )
        | tostring
        | gsub("<[^>]+>"; "")
        | gsub("\\s+"; " ")
        | gsub("^\\s+|\\s+$"; "")
    ' <<<"$json")

    [ -n "$abs" ] && [ "$abs" != "null" ] && echo "$abs"
}

# Keywords via Springer
keywords_from_springer () {
    local json=$1
    if ! jq -e . >/dev/null 2>&1 <<<"$json"; then
        return 0
    fi

    local out
    out=$(jq -r '
        def norm(s):
          s | tostring
            | ascii_downcase
            | gsub("^\\s+|\\s+$"; "");

        if (.records | type == "array") and (.records | length > 0) then
          (
            .records[0].keyword
            | if type == "array" then
                ( map(norm(.)) )
              elif type == "string" then
                ( split("[,;|]"; "x") | map(norm(.)) )
              else
                []
              end
            | map(select(length > 0))
            | unique
            | join(", ")
          )
        else "" end
    ' <<<"$json")

    [ -n "$out" ] && [ "$out" != "null" ] && echo "$out"
}

# event via springer : super pour le nom de la conf également, type GSI
event_from_springer () {
    local json=$1
    if echo "$json" | jq empty 2>/dev/null; then
        local springer_nameIssue=$(echo "$json" | jq -r '.records[0].conferenceInfo[] | select(.confSeriesName) | "\(.confSeriesName)"')
        [ -n "$springer_nameIssue" ] && echo "$springer_nameIssue"
    fi
}

# Récupération des abstracts (OpenAlex, Semantic Scholar)
fetch_abstract_complement () {
    local doi=$1
    local abstract="No abstract available"
    local candidates=()

    # Fonction de sécurité pour les appels API avec suivi des redirections
    safe_curl () {
        curl -Ls --connect-timeout 5 --retry 3 --retry-delay 2 "$1" || echo ""
    }

    # 1. OpenAlex
    local openalex_response
    openalex_response=$(safe_curl "https://api.openalex.org/works/https://doi.org/$doi")
    if echo "$openalex_response" | jq empty 2>/dev/null; then
        # Recomposition simple depuis abstract_inverted_index (ok dans la majorité des cas)
        local openalex_abstract
        openalex_abstract=$(echo "$openalex_response" | jq -r '
            .abstract_inverted_index
            | ( to_entries? // [] )
            | sort_by( .value[0] )
            | map(.key)
            | join(" ")
        ')
        [ -n "$openalex_abstract" ] && [ "$openalex_abstract" != "null" ] && candidates+=("$openalex_abstract")
    fi

    # 2. Semantic Scholar
    local semantics_response
    semantics_response=$(safe_curl "https://api.semanticscholar.org/graph/v1/paper/DOI:$doi?fields=abstract")
    if echo "$semantics_response" | jq empty 2>/dev/null; then
        local semantics_abstract
        semantics_abstract=$(echo "$semantics_response" | jq -r '.abstract // ""')
        [ -n "$semantics_abstract" ] && [ "$semantics_abstract" != "null" ] && candidates+=("$semantics_abstract")
    fi

    # 3. Sélection du candidat le plus long (après trim)
    for candidate in "${candidates[@]}"; do
        local trimmed
        trimmed="$(echo "$candidate" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
        if [ -n "$trimmed" ] && [ "$trimmed" != "null" ]; then
            if [ "${#trimmed}" -gt "${#abstract}" ] || [ "$abstract" = "No abstract available" ]; then
                abstract="$trimmed"
            fi
        fi
    done

    echo "$abstract"
}

# Récupère la citation formattée d'après un DOI
get_citation () {
    local doi=$1
    citation=$(curl -s https://citation.doi.org/format?doi=$doi&style=springer-basic-author-date-no-et-al-with-issue&lang=en-US | tail -n 1)
    echo "$citation" | sed 's/^1.[[:space:]]//g' | sed 's/.$//g'
}

# Ajoute un zéro si le mois ou le jour est entre 1 et 9
pad_zero () {
    printf "%02d" "$1"
}

